This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-07T13:24:05.883Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cmd/main.go
config/env.go
docker-compose.yml
go.mod
go.sum
service/rabbitmq/client.go
service/websocket/broadcast.go
service/websocket/connections.go
service/websocket/handler.go
service/websocket/routes.go
types/auth.go
types/connection.go
types/message.go

================================================================
Repository Files
================================================================

================
File: cmd/main.go
================
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/hoyci/ms-chat/ws-service/config"
	"github.com/hoyci/ms-chat/ws-service/service/rabbitmq"
	"github.com/hoyci/ms-chat/ws-service/service/websocket"
)

func main() {
	path := fmt.Sprintf("0.0.0.0:%d", config.Envs.Port)

	rabbitmq.Init()
	defer rabbitmq.GetChannel().Close()
	go websocket.StartBroadcastConsumer()

	websocket.RegisterRoutes()

	log.Println("Listening on:", path)
	http.ListenAndServe(path, nil)
}

================
File: config/env.go
================
package config

import (
	"log"

	"github.com/caarlos0/env"
)

type Config struct {
	Port        int    `env:"PORT" envDefault:"8081"`
	Environment string `env:"ENVIRONMENT" envDefault:"development"`
	RabbitMQURL string `env:"RABBITMQ_URL" envDefault:"amqp://user:password@localhost:5672/"`
}

var Envs = initConfig()

func initConfig() Config {
	var cfg Config
	err := env.Parse(&cfg)

	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	return cfg
}

================
File: docker-compose.yml
================
services:
  rabbitmq:
    image: rabbitmq:management
    container_name: rabbitmq
    restart: always
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: user
      RABBITMQ_DEFAULT_PASS: password
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  rabbitmq_data:

================
File: go.mod
================
module github.com/hoyci/ms-chat/ws-service

go 1.23.1

require (
	github.com/caarlos0/env v3.5.0+incompatible
	github.com/golang-jwt/jwt v3.2.2+incompatible
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
	github.com/rabbitmq/amqp091-go v1.10.0
)

================
File: go.sum
================
github.com/caarlos0/env v3.5.0+incompatible h1:Yy0UN8o9Wtr/jGHZDpCBLpNrzcFLLM2yixi/rBrKyJs=
github.com/caarlos0/env v3.5.0+incompatible/go.mod h1:tdCsowwCzMLdkqRYDlHpZCp2UooDD3MspDBjZ2AD02Y=
github.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=
github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=
github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/rabbitmq/amqp091-go v1.10.0 h1:STpn5XsHlHGcecLmMFCtg7mqq0RnD+zFr4uzukfVhBw=
github.com/rabbitmq/amqp091-go v1.10.0/go.mod h1:Hy4jKW5kQART1u+JkDTF9YYOQUHXqMuhrgxOEeS7G4o=

================
File: service/rabbitmq/client.go
================
package rabbitmq

import (
	"log"

	"github.com/hoyci/ms-chat/ws-service/config"
	amqp "github.com/rabbitmq/amqp091-go"
)

var conn *amqp.Connection
var channel *amqp.Channel

func Init() {
	var err error
	conn, err = amqp.Dial(config.Envs.RabbitMQURL)
	if err != nil {
		log.Fatalf("Failed to connect to RabbitMQ: %v", err)
	}

	channel, err = conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open channel: %v", err)
	}

	err = channel.ExchangeDeclare(
		"chat_events",
		"headers",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		log.Fatalf("Failed to declare exchange: %v", err)
	}

	createQueue("persistence_queue", amqp.Table{
		"x-match":     "any",
		"persistence": "true",
	})

	createQueue("broadcast_queue", amqp.Table{
		"x-match":   "any",
		"broadcast": "true",
	})
}

func createQueue(name string, headers amqp.Table) {
	q, _ := channel.QueueDeclare(
		name,
		true,
		false,
		false,
		false,
		nil,
	)

	channel.QueueBind(
		q.Name,
		"",
		"chat_events",
		false,
		headers,
	)
}

func GetChannel() *amqp.Channel {
	return channel
}

================
File: service/websocket/broadcast.go
================
package websocket

import (
	"encoding/json"
	"log"

	"github.com/hoyci/ms-chat/ws-service/service/rabbitmq"
	"github.com/hoyci/ms-chat/ws-service/types"
)

func StartBroadcastConsumer() {
	ch := rabbitmq.GetChannel()

	msgs, _ := ch.Consume(
		"broadcast_queue",
		"",
		false,
		false,
		true,
		false,
		nil,
	)

	log.Println("[CONSUMER] Iniciando consumer do broadcast...")
	for msg := range msgs {
		log.Printf("[BROADCAST] Mensagem recebida: %s", string(msg.Body))
		var message types.Message
		json.Unmarshal(msg.Body, &message)

		connections := GetRoomConnections(message.Room)
		for _, conn := range connections {
			log.Printf("Verificando conexão %s para sala %s", conn.ClientID, message.Room)
			if _, ok := conn.Rooms[message.Room]; ok {
				log.Printf("Conexão %s está na sala", conn.ClientID)
				if conn.ClientID != message.ClientID {
					log.Printf("Enviando para %s", conn.ClientID)
					err := conn.Channel.WriteJSON(message)
					if err != nil {
						log.Printf("Erro ao enviar para %s: %v", conn.ClientID, err)
					}
				}
			}
		}

		msg.Ack(false)
	}
}

================
File: service/websocket/connections.go
================
package websocket

import (
	"sync"

	"github.com/hoyci/ms-chat/ws-service/types"
)

var (
	connections = make(map[string]types.Connection)
	mu          sync.RWMutex
)

func AddConnection(clientID string, conn types.Connection) {
	mu.Lock()
	defer mu.Unlock()
	connections[clientID] = conn
}

func RemoveConnection(clientID string) {
	mu.Lock()
	defer mu.Unlock()
	delete(connections, clientID)
}

func GetRoomConnections(room string) []types.Connection {
	mu.RLock()
	defer mu.RUnlock()

	result := make([]types.Connection, 0)
	for _, conn := range connections {
		if _, ok := conn.Rooms[room]; ok {
			result = append(result, types.Connection{
				ClientID: conn.ClientID,
				UserID:   conn.UserID,
				Rooms:    conn.Rooms,
				Channel:  conn.Channel,
			})
		}
	}
	return result
}

================
File: service/websocket/handler.go
================
package websocket

import (
	"encoding/json"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"github.com/hoyci/ms-chat/ws-service/service/rabbitmq"
	"github.com/hoyci/ms-chat/ws-service/types"
	amqp "github.com/rabbitmq/amqp091-go"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin:     func(r *http.Request) bool { return true },
}

func HandleWebsocket(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Fatalln("Failed to update connection to WS", err)
		return
	}

	userIDStr := r.URL.Query().Get("userId")
	userID, err := strconv.Atoi(userIDStr)
	if err != nil {
		log.Println("Invalid userId:", err)
		return
	}

	clientID := uuid.New().String()

	AddConnection(clientID, types.Connection{
		ClientID: clientID,
		UserID:   userID,
		Rooms:    make(map[string]bool),
		Channel:  conn,
	})

	go manageConnection(conn, clientID)
}

func manageConnection(conn *websocket.Conn, clientID string) {
	defer func() {
		RemoveConnection(clientID)
		conn.Close()
	}()

	ch := rabbitmq.GetChannel()

	for {
		var msg types.Message
		err := conn.ReadJSON(&msg)
		if err != nil {
			log.Fatalln("Read error:", err)
			return
		}

		switch msg.Type {
		case "join_room":
			mu.Lock()
			if connData, exists := connections[clientID]; exists {
				connData.Rooms[msg.Room] = true
				connections[clientID] = connData
			}
			mu.Unlock()

		case "leave_room":
			mu.Lock()
			if connData, exists := connections[clientID]; exists {
				delete(connData.Rooms, msg.Room)
				connections[clientID] = connData
			}
			mu.Unlock()
		}

		msg.ClientID = clientID
		msg.Timestamp = time.Now().UTC().Format(time.RFC3339)

		body, _ := json.Marshal(msg)
		log.Printf("[PUBLISH] Enviando mensagem para exchange. Body: %s", string(body))

		err = ch.Publish(
			"chat_events",
			"",
			false,
			false,
			amqp.Publishing{
				Headers: amqp.Table{
					"persistence": "true",
					"broadcast":   "true",
				},
				ContentType: "application/json",
				Body:        body,
			},
		)

		if err != nil {
			log.Println("Failed to publish message:", err)
		} else {
			log.Println("[SUCESSO] Mensagem publicada no exchange")
		}
	}
}

================
File: service/websocket/routes.go
================
package websocket

import "net/http"

func RegisterRoutes() {
	http.HandleFunc("/ws", HandleWebsocket)
}

================
File: types/auth.go
================
package types

import "github.com/golang-jwt/jwt/v5"

type CustomClaims struct {
	ID       string `json:"id"`
	UserID   int    `json:"userId"`
	Username string `json:"username"`
	Email    string `json:"email"`
	jwt.RegisteredClaims
}

================
File: types/connection.go
================
package types

import "github.com/gorilla/websocket"

type Connection struct {
	ClientID string
	UserID   int
	Rooms    map[string]bool
	Channel  *websocket.Conn
}

================
File: types/message.go
================
package types

type Message struct {
	UserID    int    `json:"user_id"`
	Room      string `json:"room"`
	Content   string `json:"content"`
	Timestamp string `json:"timestamp"`
	ClientID  string `json:"client_id"`
	Type      string `json:"type"`
}
